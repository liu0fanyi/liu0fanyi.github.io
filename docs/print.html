<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Larning</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><div>TinyRenderer</div></li><li class="chapter-item expanded "><a href="tinyRenderer/tinyRenderer_lesson1.html"><strong aria-hidden="true">1.</strong> TinyRenderer-lesson1</a></li><li class="chapter-item expanded "><a href="tinyRenderer/tinyRenderer_lesson2.html"><strong aria-hidden="true">2.</strong> TinyRenderer-lesson2</a></li><li class="chapter-item expanded "><a href="tinyRenderer/tinyRenderer_lesson3.html"><strong aria-hidden="true">3.</strong> TinyRenderer-lesson3</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Larning</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tinyrenderer笔记-lesson1"><a class="header" href="#tinyrenderer笔记-lesson1"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-1:-Bresenham%E2%80%99s-Line-Drawing-Algorithm">tinyRenderer笔记-lesson1</a></a></h2>
<h3 id="最简单的画线实现"><a class="header" href="#最简单的画线实现">最简单的画线实现</a></h3>
<ul>
<li>简单步进, 划分100，每次步进一点点，最后画条线
<img src="tinyRenderer/image/first_attempt.png" alt="first_attempt" /></li>
<li>问题：低效，依赖于步进长度，如果线很长，步进长度短会出现大裂缝(采样不足)
<img src="tinyRenderer/image/first_attempt_problem.png" alt="first_attempt_problem" /></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>void line(int x0, int y0, int x1, int y1, TGAImage &amp;image, TGAColor color) { 
    for (float t=0.; t&lt;1.; t+=.01) { 
        int x = x0 + (x1-x0)*t; 
        int y = y0 + (y1-y0)*t; 
        image.set(x, y, color); 
    } 
}
<span class="boring">}</span></code></pre></pre>
<h3 id="second"><a class="header" href="#second">second</a></h3>
<ul>
<li>步进长度其实很容易得到，这里用x的的步进作为实际步进长度，但是这有错误(erroneous)</li>
<li>计算当前步进比例<code>t</code></li>
<li><code>y = y0 + (y1 - y0) * t</code></li>
<li>问题：一条线正常，另一条有洞，没有第三条线
<ul>
<li>第一条和第三条，是相同两条线，只是颜色不同，方向不同，目前处理不了
<img src="tinyRenderer/image/second_attempt.png" alt="second_attempt" /></li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>void line(int x0, int y0, int x1, int y1, TGAImage &amp;image, TGAColor color) { 
    for (int x=x0; x&lt;=x1; x++) { 
        float t = (x-x0)/(float)(x1-x0); 
        int y = y0*(1.-t) + y1*t; 
        image.set(x, y, color); 
    } 
}

line(13, 20, 80, 40, image, white); 
line(20, 13, 40, 80, image, red); 
line(80, 40, 13, 20, image, red);
<span class="boring">}</span></code></pre></pre>
<h3 id="third"><a class="header" href="#third">third</a></h3>
<ul>
<li>上面红线有洞是因为，纵向y比横向x大，导致采样不足，需要哪个大用哪个作为步进长度，这里的操作是如果steep，交换x和y，</li>
<li>然后保证前后两点前面的x比后面的小，就是大了就交换一下</li>
<li>问题：到这里为止已经基本能保证画线的需求，但是效率不高
<img src="tinyRenderer/image/third_attempt.png" alt="third_attempt" /></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>void line(int x0, int y0, int x1, int y1, TGAImage &amp;image, TGAColor color) { 
    bool steep = false; 
    if (std::abs(x0-x1)&lt;std::abs(y0-y1)) { // if the line is steep, we transpose the image 
        std::swap(x0, y0); 
        std::swap(x1, y1); 
        steep = true; 
    } 
    if (x0&gt;x1) { // make it left−to−right 
        std::swap(x0, x1); 
        std::swap(y0, y1); 
    } 
    for (int x=x0; x&lt;=x1; x++) { 
        float t = (x-x0)/(float)(x1-x0); 
        int y = y0*(1.-t) + y1*t; 
        if (steep) { 
            image.set(y, x, color); // if transposed, de−transpose 
        } else { 
            image.set(x, y, color); 
        } 
    } 
}
<span class="boring">}</span></code></pre></pre>
<h2 id="timings-fourth-attempt"><a class="header" href="#timings-fourth-attempt">Timings: fourth attempt</a></h2>
<ul>
<li>由于使用bevy实现上面的图像，导致这里的benchmark没法做</li>
<li>只做了阅读理解
<ul>
<li>目前代码有太多的<code>除法</code></li>
<li>没有做assets和check on going beyond the borders，就是需要<code>错误处理</code>和<code>边界判断</code></li>
<li>优化很危险，应该清楚理解代码会运行的平台。是在优化<code>graphics card</code>或者<code>just for CPU</code>，这两者完全不同。</li>
<li>代码需要<code>profiled</code></li>
<li>经过测试，<code>10%在copy color</code>，<code>70%在调用上面的画线程序</code>，这里就是需要优化的部分</li>
</ul>
</li>
</ul>
<h2 id="fourth-attempt-continued"><a class="header" href="#fourth-attempt-continued">Fourth attempt continued</a></h2>
<ul>
<li>每一次除法，都有相同的除数<code>(x1 - x0)</code>，拿到外边</li>
<li>设立一个error variable，告诉我the distance to the best straight line from out current (x,y) pixel,we increase (or decrease) y by one, and decrease the error by one as well。
<ul>
<li>个人理解，首先for循环是<code>步进dx的长度</code>，所以derror是<code>dy / dx</code>，也就是对于每次<code>前进一次x，应该前进多少y</code>,而这里<code>y是int</code>形，所有<code>只有在error &gt; .5</code>的时候，<code>y需要增加步进长度</code>，这里<code>为啥就不太清楚了</code>，有点像是四舍五入，或者是某种数值计算优化，然后<code>error会自己减掉一次步进长度</code>因为这个<code>步进长度已经被y使用了</code></li>
</ul>
</li>
<li>由于没有<code>除法</code>，<code>line</code>的效率和<code>set Image</code> 的效率差不多了</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>void line(int x0, int y0, int x1, int y1, TGAImage &amp;image, TGAColor color) { 
    bool steep = false; 
    if (std::abs(x0-x1)&lt;std::abs(y0-y1)) { 
        std::swap(x0, y0); 
        std::swap(x1, y1); 
        steep = true; 
    } 
    if (x0&gt;x1) { 
        std::swap(x0, x1); 
        std::swap(y0, y1); 
    } 
    int dx = x1-x0; 
    int dy = y1-y0; 
    float derror = std::abs(dy/float(dx)); 
    float error = 0; 
    int y = y0; 
    for (int x=x0; x&lt;=x1; x++) { 
        if (steep) { 
            image.set(y, x, color); 
        } else { 
            image.set(x, y, color); 
        } 
        error += derror; 
        if (error&gt;.5) { 
            y += (y1&gt;y0?1:-1); 
            error -= 1.; 
        } 
    } 
} 
<span class="boring">}</span></code></pre></pre>
<h2 id="timings-fifth-and-final-attempt"><a class="header" href="#timings-fifth-and-final-attempt">Timings: fifth and final attempt</a></h2>
<ul>
<li>这里<code>消除float的使用</code>，添加了一个<code>derror2</code>，然后思路和上面其实差不多，就是<code>整体*2dx</code></li>
<li>这样之后<code>set_image</code>操作的时长已经超过了<code>line</code>操作</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>void line(int x0, int y0, int x1, int y1, TGAImage &amp;image, TGAColor color) { 
    bool steep = false; 
    if (std::abs(x0-x1)&lt;std::abs(y0-y1)) { 
        std::swap(x0, y0); 
        std::swap(x1, y1); 
        steep = true; 
    } 
    if (x0&gt;x1) { 
        std::swap(x0, x1); 
        std::swap(y0, y1); 
    } 
    int dx = x1-x0; 
    int dy = y1-y0; 
    int derror2 = std::abs(dy)*2; 
    int error2 = 0; 
    int y = y0; 
    for (int x=x0; x&lt;=x1; x++) { 
        if (steep) { 
            image.set(y, x, color); 
        } else { 
            image.set(x, y, color); 
        } 
        error2 += derror2; 
        if (error2 &gt; dx) { 
            y += (y1&gt;y0?1:-1); 
            error2 -= dx*2; 
        } 
    } 
} 
<span class="boring">}</span></code></pre></pre>
<ul>
<li><a href="https://github.com/ssloy/tinyrenderer/issues/28">一些额外的优化</a>
<ul>
<li>比如其中将<code>对于steep的判断，移到了for的外面</code>，进一步降低了时间</li>
<li>并提到将<code>y1&gt;y0? 1:-1也转移到for外面</code>，也能降低时间</li>
<li>又提到现在的<code>编译器会做相关的优化</code>，因而这几步操作：<code>虽然值得有相关的意识，但现在已经没有那么必要</code>，毕竟会降低代码的可读性和复用性</li>
</ul>
</li>
</ul>
<h2 id="wireframe-rendering"><a class="header" href="#wireframe-rendering">Wireframe rendering</a></h2>
<ul>
<li>这里需要下载他提供的<code>obj文件</code></li>
<li>用bevy直接读入，并<code>parse v和f</code>，<code>f</code>是取所有的三大块里的第一小块重新组合，得注意读题...</li>
<li>然后用line画出来</li>
<li>使用<code>bevy</code>遇到的<code>问题</code>:
<ul>
<li>bevy的image的<code>起点在左上角，这里在左下角</code>，画图的时候需要特殊处理</li>
<li><code>obj文件</code>里会<code>同时出现0点和800点</code>，也就是当我<code>设置图片大小是800</code>的时候，obj文件里的<code>800会out of index</code>，需要特殊处理</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tinyrenderer笔记-lesson2"><a class="header" href="#tinyrenderer笔记-lesson2"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-2:-Triangle-rasterization-and-back-face-culling">tinyRenderer笔记-lesson2</a></a></h2>
<h2 id="old-school-method-line-sweeping-线扫就是一行一行画线完成一个三角形绘制"><a class="header" href="#old-school-method-line-sweeping-线扫就是一行一行画线完成一个三角形绘制">old-school method: Line sweeping 线扫，就是一行一行画线完成一个三角形绘制</a></h2>
<ul>
<li>
<p>先使用上一次的<code>line</code>绘制三角形的<code>contour</code></p>
</li>
<li>
<p>绘制一个三角的<code>好方法</code>需要包含以下特征</p>
<ul>
<li>simple and fust，<code>简单快速</code></li>
<li>symmetrical: the picture should not depend on the order of vertices passed to the drawing function。<code>允许输入的三个point乱序</code></li>
<li>two triangles have two common vertices, there should be no holes between them because of rasterization rounding，ai说是<code>两个三角形有共同的顶点</code>(common vertices),不应该因为光栅化的四舍五入操作(rasterization rounding)，导致顶点之间出现了空隙(hols)<code>TODO:说不上理解</code></li>
</ul>
</li>
<li>
<p><code>传统的line sweeping，线扫描过程:</code></p>
<ol>
<li>根据y-coordinates对三个point进行排序</li>
<li>同时(simultaneously)对三角形的左侧和右侧，进行栅格化Rasterize</li>
<li>在左右边界点(boundary points)之间画一条水平线段，horizontal line segment：</li>
</ol>
</li>
<li>
<p><code>提问：哪一个segment是左边的，哪一个是右边的</code></p>
<ul>
<li>假设有<code>t0,t1,t2三个点</code>，按<code>y ascending 排序</code>，则<code>boundary A 是t0-t2，boundary B 是t0-t1 和t1-t2</code></li>
<li><img src="tinyRenderer/image/boundaryAB.png" alt="" /></li>
<li>这里边界<code>boundary A 是红色的</code>，<code>boundary B 是绿色的</code></li>
<li>目前<code>boundary B 是两个部分</code>，现在要画bottom half of the triangle by cutting it horizontally，水平切一刀，切成两半，就是切两个绿线连接的那个点，<code>将三角形分成上下两半分别绘制</code></li>
<li>首先画了<code>下三角形</code>，但是并没有做之前line的那些操作，为了让线段连续，交换xy啥的。因为之后要做三角形的填充，而填充后就看不见线了，无所谓连续</li>
<li>然后就是上下分别填充的代码，放到一起，得到三个填充颜色后的彩色三角形</li>
<li><img src="tinyRenderer/image/trianglefilled.png" alt="" /></li>
</ul>
</li>
</ul>
<h2 id="方法2-the-method-i-adopt-for-my-code"><a class="header" href="#方法2-the-method-i-adopt-for-my-code">方法2 the method i adopt for my code</a></h2>
<ul>
<li>线扫line sweeping是针对早期单线程的cpu programming: 看一个新的pseudo-code伪代码</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>triangle(vec2 points[3]) { 
    vec2 bbox[2] = find_bounding_box(points); 
    for (each pixel in the bounding box) { 
        if (inside(points, pixel)) { 
            put_pixel(pixel); 
        } 
    } 
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>输入3个点，先找出一个<code>包围盒（在101有讲，就是一个能包住这三个点的最小正方形）</code>针对每一个在bounding box里的pixel，判断pixel是否在三个点组成的三角形内，如果在，put_pixel，近似于101里讲的采样方法</p>
<ul>
<li>离题：判断pixel是否在四边形内比较麻烦，这里不处理</li>
</ul>
</li>
<li>
<p>定义重心坐标</p>
<ul>
<li>101那边的定义更好理解：给定一个三角形ABC，这个三角形坐在的2维平面的任意一点都可以表示成三个顶点坐标的线性组合linear combs,只要线性组合的系数和=1</li>
<li>三角形内的任意点P，表示成：\(P=(1-u-v)A + uB + vC\)</li>
<li>文中另一个描述是：只要我们想象，放了3个重量1-u-v,u,v到点ABC上，那么三个点的重心，就在点P上。</li>
<li><code>TODO:不懂</code>也可以说点P has coordinates(u,v)，in the (oblique) basis \((A, u\vec{AB}, u\vec{AC})\)，这里看到的就是，式子展开，可以把点A-点B看成向量AB，得到下面个式子比较自然，但是coordinates(u,v) in basis的说法没有理解</li>
<li>\(P = A + u\vec{AB} +v\vec{AC}\)</li>
<li>所以进一步简化，就是找\( u\vec{AB} + v\vec{AC} + \vec{PA} = \vec{0}\)</li>
<li>可以拆分成x方向和y方向的而两个equations</li>
<li>\[$$
\begin{equation*}
\begin{cases}
u\overrightarrow{AB_{x}} &amp; +\ u\overrightarrow{AC_{x}} +\ \overrightarrow{PA_{x}} \ =\ 0\\
u\overrightarrow{AB_{y}} &amp; +\ u\overrightarrow{AC_{y}} +\ \overrightarrow{PAy} \ =\ 0
\end{cases}
\end{equation*}
$$\]</li>
<li>写成矩阵形式:</li>
<li>\[$$
\begin{equation*}
\begin{cases}
\begin{bmatrix}
u &amp; v &amp; 1
\end{bmatrix} &amp; \begin{bmatrix}
\overrightarrow{AB_{x}}\
\overrightarrow{AC_{x}}\
\overrightarrow{PA_{x}}
\end{bmatrix} \ =\ 0\
\begin{bmatrix}
u &amp; v &amp; 1
\end{bmatrix} &amp; \begin{bmatrix}
\overrightarrow{AB_{y}}\
\overrightarrow{AC_{y}}\
\overrightarrow{PA_{y}}
\end{bmatrix} \ =\ 0
\end{cases}
\end{equation*}
$$\]</li>
<li>所以要找的是一个(u, v, 1)向量，同时垂直于ABx,ACx,PAx和ABy,ACy,PAy这两个向量，就是原本两点形成向量，现在三个向量的分量形成了新的向量，容易迷糊=_=，所以只需要求个cross，叉积，就能得到uv1这个向量</li>
<li>所以现在在那个包围盒bounding box里的所有pixel都求一个重心坐标，如果其中有一个点是负值，说明这个点在三角形外，则不画出来
*实际代码操作，求出包围盒左下角右上角，通过遍历所有pixel，然后做一个clamp，确定不会超出屏幕，然后做画三角操作</li>
</ul>
</li>
</ul>
<h2 id="flat-shading-render"><a class="header" href="#flat-shading-render">flat shading render</a></h2>
<ul>
<li>首先尝试用随机颜色填充了三角形：这之后提供的代码没有使用那个<code>方法2</code>画线，那个应该对<code>点的顺序有要求</code>，没有提，<code>TODO:暂时没能成功用方法2画出彩色填充model</code></li>
<li><code>现在添加光</code>
<ul>
<li>the polygon is illuminated most brightly when it is orthogonal to the light direction垂直照射，多边形最亮</li>
<li>如果平行，那将一点光没有。</li>
<li>总结，the intensity of illumination is equal to the scalar product of the light vector and the normal to the giben triangle.the normal to the triangle can be calculated simply as the cross product of its two sides，叉积乘出三角形的垂直向量，然后与光入射向量做点积得出入射角度</li>
<li>这个课程perform linear computations on the colors，认为color线性增长，但其实128的color并非half as bright as 255， 忽略了其中的误差</li>
<li>dot product可以为负值negative。这说明光的入射角度在polygon的下方，我们可以直接丢弃相关的三角，可以允许我们快速的删除一些看不见的三角，这叫做<code>[Back-face culling](http://en.wikipedia.org/wiki/Back-face_culling)</code></li>
<li><img src="tinyRenderer/image/model_light_hole.png" alt="" /></li>
<li>注意嘴唇那里有inner cavity of the mouth is drawn on top of the lips.由于dirty clipping of invisible triangles：这种clipping只对convex shapes，凸起的形状 only。将get rid of 摆脱 这种artifact人工造物，当使用z-buffer的时候</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tinyrenderer笔记-lesson3"><a class="header" href="#tinyrenderer笔记-lesson3"><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-3:-Hidden-faces-removal-(z-buffer)">tinyRenderer笔记-lesson3</a></a></h2>
<h2 id="z-buffer-introduction"><a class="header" href="#z-buffer-introduction">z-buffer introduction</a></h2>
<ul>
<li>get rid of 摆脱 the visual artifacts 手工艺品 of the hidden faces removal we had</li>
<li>如果从后边往前画三角，可以不丢失任何一个三角，后面会覆盖前面的，就像画油画</li>
<li>画家算法理论上可以通过从后向前逐层绘制三角面来避免面消隐,但它有几个重大问题:</li>
</ul>
<ol>
<li>计算成本高。每次相机视角变化都需要重新排序整个场景,这在复杂场景下代价很大。</li>
<li>无法处理动态场景。如果场景对象在运动,绘制顺序也在变化,画家算法无法高效地处理这种情况。</li>
<li>无法确定正确顺序。有时候很难确定三角面正确的绘制顺序,从而导致面消隐现象。</li>
</ol>
<h2 id="let-us-try-to-render-a-simple-scene"><a class="header" href="#let-us-try-to-render-a-simple-scene">Let us try to render a simple scene</a></h2>
<ul>
<li>假设从上往下看三个穿插的三角形</li>
<li>三维情况如下
<ul>
<li><img src="tinyRenderer/image/triangles_three_from_top.png" alt="" /></li>
</ul>
</li>
<li>从上方看的渲染结果如下
<ul>
<li><img src="tinyRenderer/image/triangles_three_from_top_real.png" alt="" /></li>
</ul>
</li>
<li>blue部分在red前面，三个都有穿插，先画哪个都不对</li>
</ul>
<ol>
<li>画家算法无法在这个例子中工作,需要通过细致的空间分割来判断triangle之间的相对位置。</li>
<li>BSP树可以实现这种空间分割,但代价太高,难以在实时渲染中使用。</li>
<li>理想的解决方案应更加高效,避免过度依赖细致的空间分割。Z缓冲算过为每个像素记录最近的面实现了这一点,这也是它相比BSP树更加实用的原因。</li>
</ol>
<h2 id="even-simpler-let-us-lose-a-dimension-y-buffer"><a class="header" href="#even-simpler-let-us-lose-a-dimension-y-buffer">Even simpler: let us lose a dimension. Y-buffer</a></h2>
<ul>
<li>用黄色切割上面的立体图，直接干成二维的，只看切割的这条线
<ul>
<li><img src="tinyRenderer/image/triangles_three_from_top_add_yellow.png" alt="" /></li>
<li><img src="tinyRenderer/image/triangles_three_from_top_add_yellow_line.png" alt="" /></li>
</ul>
</li>
<li>our scene 是二维，所以用line()简单画了一下</li>
<li>实际显示的是从sideway，侧面看到的三角形和黄色平面的交线</li>
<li>开始render。render是1pixel height。代码里实际上是16pixels,为了在高分辨率的屏幕下也能看清楚。</li>
<li>rasterize() writes only in the first line of the image render。</li>
<li>这里定义了一个magic array <code>ybuffer</code> with dimensions(width, 1)，用minus infinity 初始化。</li>
<li>然后调用rasterize() 渲染，</li>
<li>很简单：遍历所有的x-coordinates，在p0.x和p1.x之间，计算，corresponding(相应) y-coordinate of the segment。然后检查我们在ybuffer里根据当前的xindex得到了什么。如果y-value 离camera的距离更近，则y-value更新为ybuffer，然后draw it on the screen and update the ybuffer。</li>
<li>下面提供了一下过程，step-by-step，在第一次调用rasterize() on the first (red) segment this is our memory</li>
<li>红色从左到右，表示距离由远到近，然后覆盖绿色，因为绿色更近，因而覆盖，然后蓝色，由于蓝色部分更近，因而无法完全覆盖</li>
</ul>
<h2 id="回到3d"><a class="header" href="#回到3d">回到3d</a></h2>
<ul>
<li>回到2d，z-buffer是二维的，记录每一个x,y的z深度</li>
<li>最复杂的部分是计算z-value of a pixel</li>
<li>看回y的那部分代码，其实在算的是barycentric坐标 * 所以every pixel，we want to draw simply to multiply its barycentric coordinates by the z-values of the vertices of the triangle we rasterize，就是每个坐标，都用z值乘重心坐标</li>
</ul>
<h2 id="后面留了贴纹理的作业但不晓得咋读tga放弃了"><a class="header" href="#后面留了贴纹理的作业但不晓得咋读tga放弃了">后面留了贴纹理的作业，但不晓得咋读tga，放弃了</a></h2>
<ul>
<li>参考下下一节课的代码</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
